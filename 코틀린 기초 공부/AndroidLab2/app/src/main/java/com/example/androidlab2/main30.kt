// 실무에서 비트연산은 거의 계산에는 사용되지 않고
// 정수형의 값을 비트단위로 나누어 데이터를 좀 더 작은 단위로 담아
// 경제성을 높이기 위한 용도로 사용된다.
// 예를 들어 32비트인 integer타입안에 32개의 0과 1로 된 서로 다른 값을 넣는다거나
// 앞에 5비트와 뒤에 27비트에 서로다른 값을 넣는 식으로 변수 하나에 여러개의 값을 담아
// 사용할 수 있는 것이다.
// 다만 비트연산을 사용하느 부하도 무시할 수 없으므로 주로 플래그 값을 처리하거나
// 네트워크 등에서 프로토콜의 데이터 양을 줄이기 위해 자주 사용된다.
// 정수형 변수에 비트 연산을 할때는 좌측으로 갈수록 상위 비트 우측으로 하위 비트라는걸 알아두자
// 코틀린은 모든 정수형이 부호를 포함함으로 최상위 비트를 마이너스인지 플러스인지를 표시하는
// 부호 비트로 사용하기 때문에 이 부분에는 데이터를 담지 않는 것이 좋다.

// 비트를 밀어주는 bitwise shift operators를 알아보자
// 여기에는 부호비트를 제외한 모든 비트를 좌측으로 밀어주는 shl
// 우측으로 밀어주는 shr 그리고 부호 비트를 포함하여 우측으로 밀어주는 ushr이 있다.

// 다음은 일반적인 bitwise 연산자
// and연산자는 원본과 비교대상의 값을 비트 단위로 비교하여 둘 다 1인 경우 결과를 1로 반환한다
// or연산자는 값을 비교하여 하나라도 1이면 1을 반환한다.
// xor연산자는 두 값을 비교하여 같으면 0 다르면 1을 반환한다.
// and연산자는 그 특성을 이용하여 두가지 기능으로 사용하는데
// 먼저 비트를 확인하는 용도로 원하는 위치에만 1을 넘어 비교해보면 1인지 0인지 확인해 볼 수 있다.
// 또한 비트에 clear연산 즉 0으로 만들어 줄 수 도 있다
// and연산자를 사용하여 비트를 0으로 만들고싶은 부분에만 0을 넣어
// 연산해주면 1인 부분만 남고 나머지는 모두 clear된다.
// or연산자는 반대로 비트의 set연산, 즉 비트 값을 1로 설정하고 싶을 때 사용하는데
// 비트를 1로 만들고 싶은 부분에만 1을 넣어 연산해주면 0인 부분은 그대로 남고 1인 부분만 set이 된다
// 그리고 xor연산자는 비교할 두 값이 비트별로 동일한지를 확인하는데 사용한다.

// 마지막으로 inv()함수인데 이것은 비트를 모두 반전시키는 역할을 한다
// 0은 1로 1은 0으로 반전된다.
fun main(){
    var bitData: Int = 0b10000

    bitData = bitData or(1 shl 2)
    println(bitData.toString(2)) // 2진법으로

    var result = bitData and(1 shl 4)
    println(result.toString(2))

    println(result shr 4)

    bitData = bitData and((1 shl 4).inv())
    println(bitData.toString(2))

    println((bitData xor(0b10100)).toString(2))
}